#include "dia.h"

extern uint8_t DIA_VERBOSE_LEVEL;
extern char DIA_VERSION[];
extern char* DIA_CODE_FILE_NAME;
extern FILE* yyout;

dia_node* dia_string(dia_node* arg) {
  DIA_DEBUG("Dia String: %s\n", arg->name);
  return arg;
}

dia_node* dia_integer(dia_node* arg) {
  DIA_DEBUG("Dia Integer: %s\n", arg->name);
  return arg;
}

dia_node* dia_double(dia_node* arg) {
  DIA_DEBUG("Dia Double: %s\n", arg->name);
  return arg;
}

// Utility
void dia_free_node (dia_node* node) {
  /* dia_node
   * - name (char*)
   * - generated_code (char*)
   * - next_parameter (dia_node*)
   * - next_function  (dia_node*)
   */

  // This might take time, because the structure of dia_node is
  // a single linked list. I should benchmark and calculate which
  // approach would be appropriate.
  if (node->next_parameter != NULL)  dia_free_node(node->next_parameter);
  if (node->next_function != NULL)   dia_free_node(node->next_function);
  if (node->name != NULL) {
    memset(node->name, 0, strlen(node->name));
    free(node->name);
  }

  memset(node, 0, sizeof(dia_node));
  free(node);
}

// Predefined functions

void dia_puts(dia_node* node) {
  DIA_DEBUG("dia_puts\n");
  // We don't need to check type of parameters;

  fputs("std::cout<<", yyout);
  for (node = node->next_parameter; node != NULL; node = node->next_parameter)
    fprintf(yyout, "%s<<", node->name);
  fputs("std::endl;\n", yyout);
}

void dia_print(dia_node* node) {
  DIA_DEBUG("dia_print\n");
  // We don't need to check type of parameters;

  fputs("std::cout<<", yyout);
  for (node = node->next_parameter; node != NULL; node = node->next_parameter)
    fprintf(yyout, "%s<<", node->name);
  fputs("std::endl;\n", yyout);
}


// Generate function
void dia_generate_code(dia_node* node) {
  typedef struct {
    char* identifier;
    void (*handler)(dia_node* node);
  } dia_predefined_function;

  dia_predefined_function functions[] = {
    {"puts", dia_puts},
    {"print", dia_print},
  };

  int i=0;
  int size = sizeof(functions) / sizeof(functions[0]);

  printf("size: %d\n", size);

  for (; i<size; i++) {
    if(!strcmp(node->name, functions[i].identifier)) {
      functions[i].handler(node);
      break;
    }
  }

  if (i == size)
    fprintf(stderr, "Undefined method: %s\n", node->name);

  return;
}


// The main function

void _dia_comment_generating() {
  DIA_DEBUG("Generating an explanation comment in the main function...\n");

  fputs("/*\n", yyout);
  fputs(" * This code is generated by diac, the Dia programming language compiler.\n", yyout);
  fputs(" * Version Info: ", yyout);
  fputs(DIA_VERSION, yyout);
  fputs("\n", yyout);
  fputs(" *\n", yyout);
  fputs(" * Original Source Code:\n", yyout);
  fputs(" *\n", yyout);
  fputs(" * ```dia\n", yyout);
  fputs(" * ", yyout);

  FILE* source_file = fopen(DIA_CODE_FILE_NAME, "r");
  while(1) {
    char c = fgetc(source_file);
    DIA_DEBUG_2("read byte %02x from the %s file;\n", c, DIA_CODE_FILE_NAME);
    if (c == EOF || c == (char)0xff) {
      fputs("\n", yyout);
      break;
    }
    else if (c == '\n')
      fputs("\n * ", yyout);
    else
      fputc(c, yyout);
  }
  fclose(source_file);

  fputs(" * ```\n", yyout);
  fputs(" */\n", yyout);
}

void dia_main(dia_node* node) {
  _dia_comment_generating();

  DIA_DEBUG("Generating the main function code...\n");

  fputs("#include<iostream>\n", yyout);
  fputs("int main(int argc, char** argv) {\n", yyout);

  for (dia_node* _node = node; _node != NULL; _node = _node->next_function)
    dia_generate_code(_node);

  fputs("}", yyout);
  dia_free_node(node);
}
